[["creating-your-first-graph.html", "Chapter 5 Creating your first graph 5.1 Resources 5.2 Learning objectives 5.3 Prerequisites 5.4 The ggplot2 system 5.5 Different geoms using real data", " Chapter 5 Creating your first graph Data visualization is an efficient way of understanding data. By using graphs we can communicate characteristics of a data set that would have been impossible with a limited number of summary statistics (central tendencies, spread etc.). In Chapter 2 of his book (Spiegelhalter 2019), Spiegelhalter touches upon this fact when he describes different types of graphs and their use to understand different data sets. A great argument for the use of data visualization is the need to understand what factors might explain variation in a given data set (Spiegelhalter 2019). In this sense, data visualization can be thought of as an initial step in understanding data, data visualization as an exploratory tool. RStudio is a powerful environment for data visualization. Together with R (that is excellent for creating graphs), you can create and preview figures that represents your data in RStudio. R has got several systems for creating figures, plots, graphs. In this course, we will use ggplot2. Another system for plotting comes with the base installation of R. This is sometimes referred to as base R (see this tutorial, or this. Another well described and used system is lattice. We choose ggplot2 because it works well with the tidyverse, and it is well described. 5.1 Resources There are several good resources aimed at ggplot2: Chapter 4 in R for data science The ggplot2 book The ggplot2 cheatsheet 5.2 Learning objectives After this session, you should be able to answer: What are geoms? What is mapping data to aesthetics? What are theme components? You should also be able to create your first graph. 5.3 Prerequisites To follow the exercises below you will need to some data. For the purpose of this course, I have created a package that contains the data sets we need. In this session we will work with the cyclingstudy data set. To install the package (exscidata) you will need another package called remotes. The code below first checks if the package remotes is installed, or more specifically, if \"remotes\" cannot be found in the list of installed packages. Using the if function makes install.packages(remotes) conditional. If we do not find \"remotes\" among installed packages, then install remotes. The next line of code does the same with the exscidata package. However, since the package is not on CRAN but hosted on github we will need to use remotes to install it. The part of the second line of code that says remotes::install_github(\"dhammarstrom/exscidata\") uses the function install_github without loading the remotes package. The last line of the code below loads the package exscidata using the library function. # Check if remotes is not installed, if TRUE, install remotes if (!&quot;remotes&quot; %in% installed.packages()) install.packages(remotes) # Check if exscidata is not installed, if TRUE, install exscidata from github if (!&quot;exscidata&quot; %in% installed.packages()) remotes::install_github(&quot;dhammarstrom/exscidata&quot;) # Load exscidata library(exscidata) Next we need to load the tidyverse package. This package in turn loads several packages that we will use when transforming data and making our figures. I will include the line of code that checks if the package is installed, if not R will download and install it. We subsequently load the package using library. # Check if tidyverse is not installed, if TRUE, install remotes if (!&quot;tidyverse&quot; %in% installed.packages()) install.packages(tidyverse) library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 -- ## v ggplot2 3.3.2 v purrr 0.3.4 ## v tibble 3.0.3 v dplyr 1.0.2 ## v tidyr 1.1.2 v stringr 1.4.0 ## v readr 1.4.0 v forcats 0.5.0 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() We are now ready to explore the data set. But first we should talk about the main components of the ggplot2 system. 5.4 The ggplot2 system When using the ggplot2 system we can think of the resulting graph as containing data that has been mapped to different coordinates, colors, shapes, sizes and other attributes that determines what is being visualized. We are using different geometric representations of the data in the visualization. When we map data in ggplot we use a specific function, aes() (short for aesthetic). We will use this inside the main engine, ggplot(). For this first simple example we will create a data set. When you simulate data in R you can tell R what should be the starting point in the random number generator. Using set.seed(100) we can recreate the same numbers from what ever number generator we later use. In the example below, we use rnorm() to simulate numbers from a normal distribution. The settings n = 10, mean = 0 and sd = 1 we will simulate randomly picking 10 numbers from a distribution that has a mean of 0 and a standard deviation of 1. These numbers are stored in a data frame that as assigned to an object that we have named dat. set.seed(99) dat &lt;- data.frame(x = rnorm(10, mean = 0, sd = 1), y = rnorm(10, mean = 10, sd = 2)) The dataset consist of two variables. We will start by creating the canvas, this basically sets the border of the figure we want to create. The ggplot() function takes the dataset as its first argument, followed by the aes() function that is used to map data to coordinates and other attributes. ggplot(dat, aes(x = x, y = y)) Figure 5.1: An empty ggplot canvas. As you can see in Figure 5.1 the code above creates an empty canvas that has enough room to visualize our data. The x- and y-axes are adjusted to give room for graphical representations of the data. Next we need to add geometric shapes. These are functions that we add to the plot using the + sign. These functions all start with geom_ and has and ending that describes the geoms, like point, line, etc. We will add geom_point() to our empty canvas as plotted in Figure 5.1. The geom_point function inherits the mapping from from ggplot(). This means that we do not need to specify anything in geom_point at this stage. ggplot(dat, aes(x = x, y = y)) + geom_point() Figure 5.2: A ggplot canvas with points added. In Figure 5.2 we have added black points to each x- and y-coordinate representing x and y from our data set. To extend the example we will add data to our dataset. In the code below, we create a new variable in the dataset using $ effectively giving us a new column in the data. We use rep(\"A\", 5) to replicate the letter A five times and the same for B. The c() function combines the two in a single vector. We can use head(dat) to see what we accomplished with these operations. The head() function prints the first six rows from the dataset. dat$z &lt;- c(rep(&quot;A&quot;, 5), rep(&quot;B&quot;, 5)) head(dat) ## x y z ## 1 0.2139625 8.508462 A ## 2 0.4796581 11.843101 A ## 3 0.0878287 11.500109 A ## 4 0.4438585 4.982892 A ## 5 -0.3628379 3.918132 A ## 6 0.1226740 10.000532 B We can see that we have an additional variable z that contains \"A\" and \"B\". This new variable can be used to add more information to the plot. Lets say that we want to map the z variable to different colors. We do this by adding color = z to aes. This means that we want the z variable to determine colors. ggplot(dat, aes(x = x, y = y, color = z)) + geom_point() Figure 5.3: A ggplot canvas with colored points added. In Figure 5.3 we can see that different colors are used for the two letters \"A\" and \"B\". Other attributes can also be specified like shape, fill or size. The shape specifies the appearance of the points. When we use use data to map to shapes, ggplot2 will start from the standard shape. Figure 5.4: Shapes in R Possible shapes in the standard framework in R are shown in Figure 5.4. We may use this information to either fix the shape of the points. Lets say that instead of colored points we want filled points. We would change the color = z argument to fill = z instead and select a point shape that can be filled (shapes 21-25, see Figure 5.4. Notice in the code below that shape = 21 has been added to geom_point(). We have specified how points should be displayed. ggplot(dat, aes(x = x, y = y, fill = z)) + geom_point(shape = 21) Figure 5.5: A ggplot canvas with filled points added. Since shape is an attribute it to can be mapped by data. If we want data to determine both shape and fill we could add this information in the aes() function by setting both shape = z and fill = z. We now have to specify what shapes ggplot should use in order to be sure we can combine both shapes and fill. We will use scale_fill_manual and scale_shape_manual to do this. These functions takes lets you specify different values for aesthetics. Notice that we removed shape = 21 from the geom_point() function, but we added size to increase the size of the points. ggplot(dat, aes(x = x, y = y, fill = z, shape = z)) + geom_point(size = 3) + scale_fill_manual(values = c(&quot;red&quot;, &quot;green&quot;)) + scale_shape_manual(values = c(21, 23)) Figure 5.6: Data mapped to fill and shape, and size specified manually to override the default. 5.5 Different geoms using real data We have now seen that the basic ggplot2 figure maps underlying data to coordinates and geometric representations, such as points. We will go further by using some real data. We will be using the cyclingstudy dataset from the exscidata-package. We will start by loading the data and select a few columns that we are interested in. By using data(\"cyclingstudy\") we will load the data set that is part of the exscidata-package to our environment. By looking at the environment tab you can see that this operation adds a data set to the environment. It has 80 observations and 101 variables. Using the glimpse() function from dplyr (which is loaded by loading tidyverse) we will get an overview of all variables in the dataset. I have omitted the output from the code below # Load the data and have a first look data(&quot;cyclingstudy&quot;) glimpse(cyclingstudy) We will store a selected set of variables in a new object for ease of use. We will call this object cycdat. We select variables using the function with the very suitable name select where the first argument specifies the dataset, following arguments specifies what variables we want. Lets say that we are interested in squat jump height. The exscidata package comes with descriptions of the datasets. By writing ?cyclingstudy in your console you will see the description of the data in your help tab. Squat jump is recorded as sj.max, we select this variable together with subject, group and timepoint to create a smaller data set. # Assign a selected set of variables to a smaller data set cycdat &lt;- select(cyclingstudy, subject, group, timepoint, sj.max) # Printing the data set cycdat ## # A tibble: 80 x 4 ## subject group timepoint sj.max ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 INCR pre 31.0 ## 2 2 DECR pre 31.6 ## 3 3 INCR pre 26.8 ## 4 4 DECR pre 29.2 ## 5 5 DECR pre 31.2 ## 6 6 INCR pre 34.2 ## 7 7 MIX pre 30.1 ## 8 8 MIX pre 32.8 ## 9 9 MIX pre 22.7 ## 10 10 INCR pre 29.7 ## # ... with 70 more rows By printing the object we can see that we have a tibble of 80 rows and 4 columns. A tibble can to a large extent be regarded as a data frame, and we will use these words interchangeably. Tibbles are new in the sense that they are developed as part of the tidyverse (Wickham and Grolemund 2017).1 Printing a tibble will display the first 10 rows as we can see from the resulting output. 5.5.1 A plot of values per group Lets say that we want to see how the values differs between groups. Boxplots are a good way to start as they will bring a standardized way of summarizing data. Boxplots can be plotted using the geom_boxplot function. Notice below that we put group on the x-axis (the first argument in the aes function) and sj.max on the y-axis. By doing so ggplot will make the x-axis discrete and the y-axis continuous. # Creating a boxplot of all values per group ggplot(cycdat, aes(group, sj.max)) + geom_boxplot() ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). Figure 5.7: Boxplot of all data per group from the cycling dataset. We can layers of more geoms to the same plot. We might want to add individual data points also. geom_jitter might be a good place to start. This geom is good as it can be plotted over a group variable and points gets jittered or spread so we avoid overlap. # Creating a boxplot of all values per group ggplot(cycdat, aes(group, sj.max)) + geom_boxplot() + geom_jitter() ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). ## Warning: Removed 4 rows containing missing values (geom_point). Figure 5.8: Boxplot and jittered points of all data per group from the cycling dataset. Notice that we get warnings saying that there are some data missing, these are removed from the calculation of summary statistics in the boxplots and omitted from plotting the values as points. 5.5.2 Data over time per group and individual In the data set we have a time variable consisting of the labels pre, meso1, meso2 and meso3. When we load the data into R we do so without providing information about the order of these labels. R will put them in alphabetical order when order is required (as in a figure). If we want to plot these data in the right order we have to tell R that these data should have an order. We will convert the timepoint variable to a factor. Factors are variables that can contain more information than what is contained in each cell. Using the factor function we will set the order of the timepoint variable. We assign this transformation of the variable to its original place in the data frame. cycdat$timepoint &lt;- factor(cycdat$timepoint, levels = c(&quot;pre&quot;, &quot;meso1&quot;, &quot;meso2&quot;, &quot;meso3&quot;)) We are now ready to plot data over time, where the time variable is correctly ordered. Lets use the boxplot again to plot all values over time. # Creating a boxplot of all values per time point ggplot(cycdat, aes(timepoint, sj.max)) + geom_boxplot() ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). Figure 5.9: Boxplot of all data per time-point from the cycling dataset. We do not see any great tendencies in the whole data set. To further explore the data we might want to have different boxes per group per time. We can accomplish this by adding fill = group to our aes function. # Creating a boxplot of all values per group over time ggplot(cycdat, aes(timepoint, sj.max, fill = group)) + geom_boxplot() ## Warning: Removed 4 rows containing non-finite values (stat_boxplot). Figure 5.10: Boxplot of all data per time-point and group from the cycling dataset. This is possible because geom_boxplots can be filled. The same separation of groups would have been accomplished using color = group, however, then the boxes would get different border colors instead. You might have noticed that the boxplots do not contain all the data, a few data points are outside 1.5 IQR (interquartile range). This, by standard definitions, defines the data point as an outlier. As mentioned above, boxplots does some summarizing and not all data is shown. To explore further we might want to track every participant. To do this we have to tell ggplot on what factor to group the data. In aes() the group argument lets you connect lines based on some grouping variable, in our case it will be subject. We will use a line to connect each participants score over time. Using color = group will additionally give every line a different color depending on which group it belongs to. # Creating a line plot of all values per participant over time, color per group ggplot(cycdat, aes(timepoint, sj.max, color = group, group = subject)) + geom_line() ## Warning: Removed 2 row(s) containing missing values (geom_path). Figure 5.11: Boxplot of all data per time-point and group from the cycling dataset. In Figure 5.11 each line represents a participant, different colors represents different groups. 5.5.3 Titles, labels and annotations Often we need to add information to the plot to better communicate its message. Such information could be appropriate titles on axes and legends and extra text needed to explain aspects of the plot. Using the labs() function we can add information that will replace variable names that are being used for all variables that have been mapped in the figure. In the figure below we will start by adding better axis titles. This information goes into x and y in labs() which simply changes the titles of the x- and y-axis. # Creating a line plot of all values per participant over time, color per group ggplot(cycdat, aes(timepoint, sj.max, color = group, group = subject)) + geom_line() + labs(x = &quot;Time-point&quot;, y = &quot;Squat jump height (cm)&quot;) ## Warning: Removed 2 row(s) containing missing values (geom_path). Figure 5.12: Boxplot of all data per time-point and group from the cycling dataset. The resulting Figure 5.12 now have better titles for each axis. Notice in the code above that titles needs to be specified with quotation marks. This is a tricky aspect of R, if we wold have omitted the quotation marks we would have told R to look for objects by the name of e.g. Time-point, and this would actually mean that we tryed to subtract time from point since - is interpreted as a minus sign. We might want to add information to the legend also. Since we specified color = group in the aes() function, the same can be manipulated in labs. Lets just add a capital G. ggplot(cycdat, aes(timepoint, sj.max, color = group, group = subject)) + geom_line() + labs(x = &quot;Time-point&quot;, y = &quot;Squat jump height (cm)&quot;, color = &quot;Group&quot;) ## Warning: Removed 2 row(s) containing missing values (geom_path). Figure 5.13: Boxplot of all data per time-point and group from the cycling dataset. We still have the original labels for the tim variable. Remember that we used the factor function above to set the order of the labels. Actually we specified the levels of the factor. We can use the same function to add better labels. In the code below, I will first change the variable in the dataset and then use the exact same code for the plot. cycdat$timepoint &lt;- factor(cycdat$timepoint, levels = c(&quot;pre&quot;, &quot;meso1&quot;, &quot;meso2&quot;, &quot;meso3&quot;), labels = c(&quot;Pre-training&quot;, &quot;Meso-cycle 1&quot;, &quot;Meso-cycle 2&quot;, &quot;Meso-cycle 3&quot;)) ggplot(cycdat, aes(timepoint, sj.max, color = group, group = subject)) + geom_line() + labs(x = &quot;Time-point&quot;, y = &quot;Squat jump height (cm)&quot;, color = &quot;Group&quot;) ## Warning: Removed 2 row(s) containing missing values (geom_path). Figure 5.14: Boxplot of all data per time-point and group from the cycling dataset. The same goes for the group variable. You can try to change the levels and labels of the grouping variable to make it more descriptive. You can type ?cyclingstudy in your console to read about the group variable and then use this infomation to write better labels using the factor function. In the factor function, the first argument is the variable you want to use as basis of your new factor, the second argument you need to specify is levels which sets the order and lastly you will need to set the labels for each level using labels =. If you write ?factor in your console you will get the help pages for the factor function. .exp{visibility: hidden;} Show example solution cycdat$group &lt;- factor(cycdat$group, levels = c(&quot;DECR&quot;, &quot;INCR&quot;, &quot;MIX&quot;), labels = c(&quot;Decreased\\nintensity&quot;, &quot;Increased\\nintensity&quot;, &quot;Mixed\\nintensity&quot;)) ggplot(cycdat, aes(timepoint, sj.max, color = group, group = subject)) + geom_line() + labs(x = &quot;Time-point&quot;, y = &quot;Squat jump height (cm)&quot;, color = &quot;Periodization strategy&quot;) Notes: Adding \\\\n in the the text string breaks the line to get two rows. See Chapter 10 in R for data science "]]
