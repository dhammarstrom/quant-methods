---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Creating your first graph

Data visualization is an efficient way of understanding data. By using graphs we can communicate characteristics of a data set that would have been impossible with a limited number of summary statistics (central tendencies, spread etc.). In Chapter 2 of his book [@RN2902], Spiegelhalter touches upon this fact when he describes different types of graphs and their use to understand different data sets. A great argument for the use of data visualization is the need to understand what factors might explain variation in a given data set [@RN2902]. In this sense, data visualization can be thought of as an initial step in understanding data, data visualization as an exploratory tool.  

RStudio is a powerful environment for data visualization. Together with R (that is excellent for creating graphs), you can create and preview figures that represents your data in RStudio. 

R has got several systems for creating figures, plots, graphs. In this course, we will use [ggplot2](https://ggplot2.tidyverse.org/). Another system for plotting comes with the base installation of R. This is sometimes referred to as base R ([see this tutorial](https://rstudio-pubs-static.s3.amazonaws.com/84527_6b8334fd3d9348579681b24d156e7e9d.html), or [this](http://www.sthda.com/english/wiki/r-base-graphs). Another well described and used system is [lattice](https://www.statmethods.net/advgraphs/trellis.html). We choose ggplot2 because it works well with the [tidyverse](https://www.tidyverse.org/), and it is well described.

## Resources
There are several good resources aimed at ggplot2: 

- [Chapter 4 in R for data science](https://r4ds.had.co.nz/data-visualisation.html)
- [The ggplot2 book](https://ggplot2-book.org/)
- [The ggplot2 cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf)

## Learning objectives

After this session, you should be able to answer:

- What are geoms?
- What is mapping data to aesthetics?
- What are theme components?

You should also be able to create your first graph.

## Prerequisites

To follow the exercises below you will need to some data. For the purpose of this course, I have created a package that contains the data sets we need. In this session we will work with the `cyclingstudy` data set. To install the package (`exscidata`) you will need another package called `remotes`. 

The code below first checks if the package `remotes` is installed, or more specifically, if `"remotes"` cannot be found in the list of installed packages. Using the `if` function makes `install.packages(remotes)` conditional. If we do not find `"remotes"` among installed packages, then install `remotes`.

The next line of code does the same with the `exscidata` package. However, since the package is not on CRAN but hosted on github we will need to use `remotes` to install it. The part of the second line of code that says `remotes::install_github("dhammarstrom/exscidata")` uses the function `install_github` without loading the remotes package. The last line of the code below loads the package `exscidata` using the `library` function.


```{r}
# Check if remotes is not installed, if TRUE, install remotes
if (!"remotes" %in% installed.packages()) install.packages(remotes)

# Check if exscidata is not installed, if TRUE, install exscidata from github
if (!"exscidata" %in% installed.packages()) remotes::install_github("dhammarstrom/exscidata")

# Load exscidata
library(exscidata)
```

Next we need to load the `tidyverse` package. This package in turn loads several packages that we will use when transforming data and making our figures. I will include the line of code that checks if the package is installed, if not R will download and install it. We subsequently load the package using `library`. 

```{r}

# Check if tidyverse is not installed, if TRUE, install remotes
if (!"tidyverse" %in% installed.packages()) install.packages(tidyverse)

library(tidyverse)


```

We are now ready to explore the data set. But first we should talk about the main components of the `ggplot2` system.

## The `ggplot2` system
When using the ggplot2 system we can think of the resulting graph as containing data that has been *mapped* to different coordinates, colors, shapes, sizes and other attributes that determines what is being visualized. We are using different geometric representations of the data in the visualization. 

When we *map* data in ggplot we use a specific function, `aes()` (short for aesthetic). We will use this inside the main engine, `ggplot()`. For this first simple example we will create a data set. When you simulate data in R you can tell R what should be the starting point in the random number generator. Using `set.seed(100)` we can recreate the same numbers from what ever "number generator" we later use. In the example below, we use `rnorm()` to simulate numbers from a normal distribution. The settings `n = 10`, `mean = 0` and `sd = 1` we will simulate randomly picking 10 numbers from a distribution that has a mean of 0 and a standard deviation of 1. These numbers are stored in a data frame that as assigned to an object that we have named `dat`.    

```{r}

set.seed(99)

dat <- data.frame(x = rnorm(10, mean = 0, sd = 1), 
                  y = rnorm(10, mean = 10, sd = 2))


```

The dataset consist of two variables. We will start by creating the canvas, this basically sets the border of the figure we want to create. The `ggplot()` function takes the dataset as its first argument, followed by the `aes()` function that is used to map data to coordinates and other attributes. 

```{r empty-canvas, fig.height=3, fig.cap = "An empty `ggplot` canvas."}

ggplot(dat, aes(x = x, y = y))

```

As you can see in Figure \@ref(fig:empty-canvas) the code above creates an "empty canvas" that has enough room to visualize our data. The x- and y-axes are adjusted to give room for graphical representations of the data. Next we need to add geometric shapes. These are functions that we add to the plot using the `+` sign. These functions all start with `geom_` and has and ending that describes the geoms, like point, line, etc.

We will add `geom_point()` to our empty canvas as plotted in Figure \@ref(fig:empty-canvas). The `geom_point` function *inherits* the mapping from from `ggplot()`. This means that we do not need to specify anything in `geom_point` at this stage.

```{r point-and-canvas, fig.height=3, fig.cap = "A `ggplot` canvas with points added."}

ggplot(dat, aes(x = x, y = y)) + geom_point()

```

In Figure \@ref(fig:point-and-canvas) we have added black points to each x- and y-coordinate representing `x` and `y` from our data set.

To extend the example we will add data to our dataset. In the code below, we create a new variable in the dataset using `$` effectively giving us a new column in the data. We use `rep("A", 5)` to replicate the letter `A` five times and the same for `B`. The `c()` function combines the two in a single vector. We can use `head(dat)` to see what we accomplished with these operations. The `head()` function *prints* the first six rows from the dataset.

```{r}

dat$z <- c(rep("A", 5), rep("B", 5))

head(dat)

```

We can see that we have an additional variable `z` that contains `"A"` and `"B"`. This new variable can be used to add more information to the plot. Let's say that we want to map the `z` variable to different colors. We do this by adding `color = z` to `aes`. This means that we want the z variable to determine colors.

```{r point-with-color, fig.height=3, fig.cap = "A `ggplot` canvas with colored points added."}

ggplot(dat, aes(x = x, y = y, color = z)) + geom_point()

```

In Figure \@ref(fig:point-with-color) we can see that different colors are used for the two letters `"A"` and `"B"`. Other attributes can also be specified like `shape`, `fill` or `size`. The `shape` specifies the appearance of the points. When we use use data to map to shapes, ggplot2 will start from the standard shape. 


```{r shapes-in-r, echo = FALSE, fig.height=5, fig.cap = "Shapes in R"}

shape_dat <- data.frame(shape = seq(0, 25), x = c(1, rep(c(1, 2, 3, 4, 5), times = 5)), 
                        y = c(6, rep(c(5, 4, 3, 2, 1), each = 5)))


ggplot(shape_dat, aes(x, y, shape = as.factor(shape))) + 
  geom_point(fill = "blue", size = 4) + 
  geom_text(aes(label = shape), nudge_y = 0.2) +
  scale_shape_manual(values = shape_dat$shape) + 
  labs(shape = "Shapes") + 
  theme_void() +
  theme(axis.title = element_blank(), 
        axis.text = element_blank(), 
        axis.ticks = element_blank(), 
        legend.position = "none")


```

Possible shapes in the standard framework in R are shown in Figure \@ref(fig:shapes-in-r). We may use this information to either fix the shape of the points. Let's say that instead of colored points we want filled points. We would change the `color = z` argument to `fill = z` instead and select a point shape that can be filled (shapes 21-25, see Figure \@ref(fig:shapes-in-r). Notice in the code below that `shape = 21` has been added to `geom_point()`. We have specified how points should be displayed.

```{r point-with-fill, fig.height=3, fig.cap = "A `ggplot` canvas with filled points added."}

ggplot(dat, aes(x = x, y = y, fill = z)) + geom_point(shape = 21)

```

Since shape is an attribute it to can be mapped by data. If we want data to determine both shape and fill we could add this information in the `aes()` function by setting both `shape = z` and `fill = z`. We now have to specify what shapes ggplot should use in order to be sure we can combine both shapes and fill. We will use `scale_fill_manual` and `scale_shape_manual` to do this. These functions takes lets you specify different values for aesthetics. Notice that we removed `shape = 21` from the `geom_point()` function, but we added size to increase the size of the points.

```{r point-with-fill-and-shape, fig.height=3, fig.cap = "Data mapped to fill and shape, and size specified manually to override the default."}

ggplot(dat, aes(x = x, y = y, fill = z, shape = z)) + 
  geom_point(size = 3) +
  scale_fill_manual(values = c("red", "green")) + 
  scale_shape_manual(values = c(21, 23))

```

## Different geoms using real data

We have now seen that the basic `ggplot2` figure maps underlying data to coordinates and geometric representations, such as points. We will go further by using some real data. We will be using the `cyclingstudy` dataset from the `exscidata`-package. We will start by loading the data and select a few columns that we are interested in. By using `data("cyclingstudy")` we will load the data set that is part of the `exscidata`-package to our environment. By looking at the environment tab you can see that this operation adds a data set to the environment. It has 80 observations and 101 variables. Using the `glimpse()` function from `dplyr` (which is loaded by loading `tidyverse`) we will get an overview of all variables in the dataset. I have omitted the output from the code below

```{r, eval = FALSE}

# Load the data and have a first look
data("cyclingstudy")
glimpse(cyclingstudy)


```


```{r echo=FALSE, message=FALSE, warning=FALSE}
data("cyclingstudy")
```


We will store a selected set of variables in a new object for ease of use. We will call this object `cycdat`. We select variables using the function with the very suitable name `select` where the first argument specifies the dataset, following arguments specifies what variables we want. Let's say that we are interested in squat jump height. The `exscidata` package comes with descriptions of the datasets. By writing `?cyclingstudy` in your console you will see the description of the data in your help tab. Squat jump is recorded as `sj.max`, we select this variable together with `subject`, `group` and `timepoint` to create a smaller data set. 

```{r}
# Assign a selected set of variables to a smaller data set
cycdat <- select(cyclingstudy, subject, group, timepoint, sj.max)
# Printing the data set
cycdat
```

By printing the object we can see that we have a tibble of 80 rows and 4 columns. A tibble can to a large extent be regarded as a data frame, and we will use these words interchangeably. Tibbles are new in the sense that they are developed as part of the tidyverse [@RNr4ds] [^a]. Printing a tibble will display the first 10 rows as we can see from the resulting output.

[^a]: See [Chapter 10 in R for data science](https://r4ds.had.co.nz/tibbles.html)

### A plot of values per group

Let's say that we want to see how the values differs between groups. Boxplots are a good way to start as they will bring a standardized way of summarizing data. Boxplots can be plotted using the `geom_boxplot` function. Notice below that we put `group` on the x-axis (the first argument in the `aes` function) and `sj.max` on the y-axis. By doing so `ggplot` will make the x-axis discrete and the y-axis continuous.

```{r sq-boxplot-simple, fig.height=3, fig.cap = "Boxplot of all data per group from the cycling dataset."}
# Creating a boxplot of all values per group
ggplot(cycdat, aes(group, sj.max)) + geom_boxplot()

```

We can layers of more geoms to the same plot. We might want to add individual data points also. `geom_jitter` might be a good place to start. This geom is good as it can be plotted over a group variable and points gets "jittered" or spread so we avoid overlap. 

```{r sq-boxplot-jitter, fig.height=3, fig.cap = "Boxplot and jittered points of all data per group from the cycling dataset."}
# Creating a boxplot of all values per group
ggplot(cycdat, aes(group, sj.max)) + geom_boxplot() + geom_jitter()

```

Notice that we get warnings saying that there are some data missing, these are removed from the calculation of summary statistics in the boxplots and omitted from plotting the values as points.

### Data over time per group and individual

In the data set we have a time variable consisting of the labels "pre", "meso1", "meso2" and "meso3". When we load the data into R we do so without providing information about the order of these labels. R will put them in alphabetical order when order is required (as in a figure). If we want to plot these data in the right order we have to tell R that these data should have an order. We will convert the `timepoint` variable to a factor. Factors are variables that can contain more information than what is contained in each cell. Using the `factor` function we will set the order of the `timepoint` variable. We assign this transformation of the variable to its original place in the data frame.

```{r}
cycdat$timepoint <- factor(cycdat$timepoint, levels = c("pre", "meso1", "meso2", "meso3"))
```

We are now ready to plot data over time, where the time variable is correctly ordered. Let's use the boxplot again to plot all values over time.

```{r sq-boxplot, fig.height=3, fig.cap = "Boxplot of all data per time-point from the cycling dataset."}
# Creating a boxplot of all values per time point
ggplot(cycdat, aes(timepoint, sj.max)) + geom_boxplot()

```

We do not see any great tendencies in the whole data set. To further explore the data we might want to have different boxes per group per time. We can accomplish this by adding `fill = group` to our `aes` function.

```{r sq-boxplot-time, fig.height=3, fig.cap = "Boxplot of all data per time-point and group from the cycling dataset."}
# Creating a boxplot of all values per group over time
ggplot(cycdat, aes(timepoint, sj.max, fill = group)) + geom_boxplot()

```

This is possible because `geom_boxplots` can be filled. The same separation of groups would have been accomplished using `color = group`, however, then the boxes would get different border colors instead. You might have noticed that the boxplots do not contain all the data, a few data points are outside 1.5 \times IQR (interquartile range). This, by standard definitions, defines the data point as an "outlier".

As mentioned above, boxplots does some summarizing and not all data is shown. To explore further we might want to track every participant. To do this we have to tell `ggplot` on what factor to group the data. In `aes()` the group argument let's you connect lines based on some grouping variable, in our case it will be `subject`. We will use a line to connect each participants score over time. Using `color = group` will additionally give every line a different color depending on which group it belongs to.


```{r sq-ind-data, fig.height=3, fig.cap = "Boxplot of all data per time-point and group from the cycling dataset."}
# Creating a line plot of all values per participant over time, color per group
ggplot(cycdat, aes(timepoint, sj.max, color = group, group = subject)) + 
geom_line()

```

In Figure \@ref(fig: sq-ind-data) each line represents a participant, different colors represents different groups.

### Labels and themes






